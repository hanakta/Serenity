<?php
// üê± –°–µ—Ä–≤–∏—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å JWT —Ç–æ–∫–µ–Ω–∞–º–∏ –≤ Serenity

namespace App\Services;

use Firebase\JWT\JWT;
use Firebase\JWT\Key;
use Firebase\JWT\ExpiredException;
use Firebase\JWT\SignatureInvalidException;

class JWTService
{
    private string $secret;
    private string $algorithm;
    private int $expiration;

    public function __construct()
    {
        $this->secret = $_ENV['JWT_SECRET'] ?? 'your-super-secret-jwt-key-here';
        $this->algorithm = $_ENV['JWT_ALGORITHM'] ?? 'HS256';
        $this->expiration = (int) ($_ENV['JWT_EXPIRATION'] ?? 86400); // 24 —á–∞—Å–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    }

    /**
     * –ì–µ–Ω–µ—Ä–∞—Ü–∏—è JWT —Ç–æ–∫–µ–Ω–∞
     */
    public function generateToken(string $userId, array $additionalClaims = []): string
    {
        $now = time();
        
        $payload = [
            'iss' => 'serenity-api', // Issuer
            'aud' => 'serenity-app', // Audience
            'iat' => $now, // Issued at
            'exp' => $now + $this->expiration, // Expiration time
            'user_id' => $userId,
            'type' => 'access'
        ];

        // –î–æ–±–∞–≤–ª—è–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ claims
        $payload = array_merge($payload, $additionalClaims);

        // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä—É—á–Ω–æ–µ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –ø—Ä–æ–±–ª–µ–º —Å Firebase JWT
        $header = json_encode(['typ' => 'JWT', 'alg' => $this->algorithm]);
        $payloadJson = json_encode($payload);
        
        $headerEncoded = $this->base64UrlEncode($header);
        $payloadEncoded = $this->base64UrlEncode($payloadJson);
        
        $signature = hash_hmac('sha256', $headerEncoded . '.' . $payloadEncoded, $this->secret, true);
        $signatureEncoded = $this->base64UrlEncode($signature);
        
        return $headerEncoded . '.' . $payloadEncoded . '.' . $signatureEncoded;
    }

    /**
     * –ì–µ–Ω–µ—Ä–∞—Ü–∏—è refresh —Ç–æ–∫–µ–Ω–∞
     */
    public function generateRefreshToken(string $userId): string
    {
        $now = time();
        
        $payload = [
            'iss' => 'serenity-api',
            'aud' => 'serenity-app',
            'iat' => $now,
            'exp' => $now + (30 * 24 * 60 * 60), // 30 –¥–Ω–µ–π
            'user_id' => $userId,
            'type' => 'refresh'
        ];

        // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä—É—á–Ω–æ–µ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –ø—Ä–æ–±–ª–µ–º —Å Firebase JWT
        $header = json_encode(['typ' => 'JWT', 'alg' => $this->algorithm]);
        $payloadJson = json_encode($payload);
        
        $headerEncoded = $this->base64UrlEncode($header);
        $payloadEncoded = $this->base64UrlEncode($payloadJson);
        
        $signature = hash_hmac('sha256', $headerEncoded . '.' . $payloadEncoded, $this->secret, true);
        $signatureEncoded = $this->base64UrlEncode($signature);
        
        return $headerEncoded . '.' . $payloadEncoded . '.' . $signatureEncoded;
    }

    /**
     * –í–∞–ª–∏–¥–∞—Ü–∏—è –∏ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–æ–∫–µ–Ω–∞
     */
    public function validateToken(string $token): array
    {
        try {
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä—É—á–Ω–æ–µ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –ø—Ä–æ–±–ª–µ–º —Å Firebase JWT
            $parts = explode('.', $token);
            if (count($parts) !== 3) {
                throw new \Exception('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ç–æ–∫–µ–Ω–∞');
            }
            
            // –î–µ–∫–æ–¥–∏—Ä—É–µ–º header –∏ payload
            $header = json_decode($this->base64UrlDecode($parts[0]), true);
            $payload = json_decode($this->base64UrlDecode($parts[1]), true);
            
            if (!$header || !$payload) {
                throw new \Exception('–ù–µ —É–¥–∞–ª–æ—Å—å –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å —Ç–æ–∫–µ–Ω');
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–ª–≥–æ—Ä–∏—Ç–º
            if ($header['alg'] !== $this->algorithm) {
                throw new \Exception('–ù–µ–≤–µ—Ä–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º');
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–ø–∏—Å—å
            $signature = $this->base64UrlDecode($parts[2]);
            $expectedSignature = hash_hmac('sha256', $parts[0] . '.' . $parts[1], $this->secret, true);
            
            if (!hash_equals($signature, $expectedSignature)) {
                throw new \Exception('–ù–µ–≤–µ—Ä–Ω–∞—è –ø–æ–¥–ø–∏—Å—å —Ç–æ–∫–µ–Ω–∞');
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Ä–µ–º—è –∏—Å—Ç–µ—á–µ–Ω–∏—è
            if (isset($payload['exp']) && $payload['exp'] < time()) {
                throw new \Exception('–¢–æ–∫–µ–Ω –∏—Å—Ç–µ–∫');
            }
            
            return $payload;
        } catch (\Exception $e) {
            // –õ–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫—É –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
            error_log('JWT Validation Error: ' . $e->getMessage());
            error_log('Token: ' . $token);
            throw new \Exception('–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω: ' . $e->getMessage());
        }
    }

    /**
     * –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–∞ –∏–∑ –∑–∞–≥–æ–ª–æ–≤–∫–∞ Authorization
     */
    public function extractTokenFromHeader(string $authHeader): ?string
    {
        if (empty($authHeader)) {
            return null;
        }

        if (preg_match('/Bearer\s+(.*)$/i', $authHeader, $matches)) {
            return $matches[1];
        }

        return null;
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∏–ø–∞ —Ç–æ–∫–µ–Ω–∞
     */
    public function isAccessToken(array $payload): bool
    {
        return isset($payload['type']) && $payload['type'] === 'access';
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∏–ø–∞ refresh —Ç–æ–∫–µ–Ω–∞
     */
    public function isRefreshToken(array $payload): bool
    {
        return isset($payload['type']) && $payload['type'] === 'refresh';
    }

    /**
     * –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –∏—Å—Ç–µ—á–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–∞
     */
    public function getTokenExpiration(array $payload): int
    {
        return $payload['exp'] ?? 0;
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä–∫–∞, –∏—Å—Ç–µ–∫ –ª–∏ —Ç–æ–∫–µ–Ω
     */
    public function isTokenExpired(array $payload): bool
    {
        $exp = $this->getTokenExpiration($payload);
        return $exp < time();
    }

    /**
     * –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –¥–æ –∏—Å—Ç–µ—á–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–∞ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
     */
    public function getTimeUntilExpiration(array $payload): int
    {
        $exp = $this->getTokenExpiration($payload);
        $timeLeft = $exp - time();
        return max(0, $timeLeft);
    }

    /**
     * –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–∞—Ä—ã —Ç–æ–∫–µ–Ω–æ–≤ (access + refresh)
     */
    public function generateTokenPair(string $userId, array $additionalClaims = []): array
    {
        return [
            'access_token' => $this->generateToken($userId, $additionalClaims),
            'refresh_token' => $this->generateRefreshToken($userId),
            'expires_in' => $this->expiration,
            'token_type' => 'Bearer'
        ];
    }

    /**
     * –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ access —Ç–æ–∫–µ–Ω–∞ —Å –ø–æ–º–æ—â—å—é refresh —Ç–æ–∫–µ–Ω–∞
     */
    public function refreshAccessToken(string $refreshToken): array
    {
        $payload = $this->validateToken($refreshToken);
        
        if (!$this->isRefreshToken($payload)) {
            throw new \Exception('–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π refresh —Ç–æ–∫–µ–Ω');
        }

        $userId = $payload['user_id'];
        return $this->generateTokenPair($userId);
    }

    /**
     * Base64 URL encode
     */
    private function base64UrlEncode(string $data): string
    {
        return rtrim(strtr(base64_encode($data), '+/', '-_'), '=');
    }

    /**
     * Base64 URL decode
     */
    private function base64UrlDecode(string $data): string
    {
        return base64_decode(str_pad(strtr($data, '-_', '+/'), strlen($data) % 4, '=', STR_PAD_RIGHT));
    }
}
